// Copyright (c) 2023 https://github.com/gio-eui
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
// SPDX-License-Identifier: MIT

//go:build ignore

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"strings"
)

// srcFolder is the folder where the font files are located
const srcFolder = "./assets/"

// destFolder is the folder where the font.go files will be generated
const destFolder = "./fonts/"

// Font is a struct that contains the font info
type Font struct {
	Family string
	Style  string
	Path   string

	FontName    string
	FamilyName  string
	PackageName string
}

// FontError is a struct that contains the font error info
type FontError struct {
	Font  *Font
	Error error
}

func main() {
	log.Println("Collecting fonts...")
	font, err := collectFonts()
	if err != nil {
		log.Fatal(err)
	}

	// Keep track of all errors
	var errs []FontError

	log.Println("Generating fonts...")
	for _, f := range font {
		// Create the font family folder
		if err := os.MkdirAll(filepath.Join(destFolder, f.FamilyName), fs.ModePerm); err != nil {
			errs = append(errs, FontError{Font: f, Error: err})
		}
		// Create the font family folder
		if err := os.MkdirAll(filepath.Join(destFolder, f.FamilyName, f.PackageName), fs.ModePerm); err != nil {
			errs = append(errs, FontError{Font: f, Error: err})
		}
		// Create the font file
		if err := generateFontFile(f); err != nil {
			errs = append(errs, FontError{Font: f, Error: err})
		}
	}

	// If there are errors, print them
	if len(errs) > 0 {
		fmt.Println(strings.Repeat("-", 80))
		log.Printf("There are %d errors\n", len(errs))
		for _, err := range errs {
			log.Printf("Font: %s, Style: %s, Error: %s\n", err.Font.Family, err.Font.Style, err.Error)
		}
		fmt.Println(strings.Repeat("-", 80))
	}
}

// collectFonts collects the fonts from the assets folder
func collectFonts() ([]*Font, error) {
	var fonts []*Font

	// List all the files in the assets folder and its subfolders recursively
	err := filepath.WalkDir(srcFolder, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		// Check if the file is a font file
		if !d.IsDir() && (strings.Compare(filepath.Ext(path), ".ttf") == 0 || strings.Compare(filepath.Ext(path), ".otf") == 0) {
			// Get the font info
			font := &Font{Path: path}
			// Get the font family name
			font.Family = filepath.Base(filepath.Dir(path))
			// Get the font style
			font.Style = filepath.Base(path)
			// Set the font name
			font.FontName = fontName(font.Style, filepath.Ext(font.Style))
			// Set the font family name
			font.FamilyName = pkgName(font.Family, filepath.Ext(font.Family))
			// Set the package name
			font.PackageName = pkgName(font.Style, filepath.Ext(font.Style))
			// Add the font to the list
			fonts = append(fonts, font)
		}
		return nil
	})
	if err != nil {
		return nil, err
	}
	return fonts, nil
}

// fontName maps "Font-Regular.ttf" to "Font Regular".
func fontName(assetName string, suffix string) string {
	s := assetName[:len(assetName)-len(suffix)]
	s = strings.Replace(s, "-", " ", -1)
	return s
}

// pkgName maps "Font-Regular.ttf" to "fontregular".
func pkgName(assetName string, suffix string) string {
	s := assetName[:len(assetName)-len(suffix)]
	s = strings.Replace(s, "-", "", -1)
	s = strings.ToLower(s)
	return s
}

// generateFontFile generates the font.go file
func generateFontFile(font *Font) error {
	// Read the font file
	f, err := os.ReadFile(font.Path)
	if err != nil {
		return err
	}

	// Prepare the buffer
	out := new(bytes.Buffer)

	// Write the header
	fmt.Fprintf(out, "// generated by go run genfonts.go; DO NOT EDIT\n\n")
	fmt.Fprintf(out, "// Package %s provides the %s TrueType font\n", font.PackageName, font.FontName)
	fmt.Fprintf(out, "//\n")
	fmt.Fprintf(out, "package %s\n\n", font.PackageName)
	fmt.Fprintf(out, "var TypeFace = %#v\n\n", font.Family)

	// Start the font data
	fmt.Fprintf(out, "var Data = []byte{")
	for i, b := range f {
		if i%16 == 0 {
			fmt.Fprintf(out, "\n\t")
		}
		fmt.Fprintf(out, "0x%02x, ", b)
	}
	fmt.Fprintf(out, "\n}\n")

	// Format the code
	src, err := format.Source(out.Bytes())
	if err != nil {
		return err
	}

	// Write the font file
	if err := os.WriteFile(filepath.Join(destFolder, font.FamilyName, font.PackageName, "font.go"), src, os.ModePerm); err != nil {
		return err
	}
	return nil
}
